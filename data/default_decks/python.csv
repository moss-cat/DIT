front,back,deck
"What are Python decorators and how do they work?","Decorators are higher-order functions that modify the behavior of other functions or methods. They use the @decorator syntax and wrap a function, enabling code reuse and separation of concerns. Under the hood, @decorator on function func is equivalent to func = decorator(func). Common uses include logging, timing, access control, caching, and input validation.",python
"Explain list comprehensions in Python and their advantages over traditional loops.","List comprehensions are concise ways to create lists based on existing iterables. Syntax: [expression for item in iterable if condition]. Advantages: more readable for simple transformations, often faster execution, reduced scope pollution, and encouraging functional programming patterns. Example: squares = [x**2 for x in range(10) if x % 2 == 0] creates squares of even numbers.",python
"What is the Global Interpreter Lock (GIL) in Python and how does it affect multithreaded programs?","The GIL is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecode simultaneously. It makes CPU-bound threads execute serially even on multicore systems. This simplifies memory management but limits thread parallelism. CPU-bound code should use multiprocessing instead of threading, while I/O-bound code still benefits from threading despite the GIL.",python
"Describe the difference between deep and shallow copy in Python.","Shallow copy (copy.copy()) creates a new object but references the same nested objects as the original. Deep copy (copy.deepcopy()) recursively copies all nested objects. Example: With a list of lists, shallow copy allows changes to inner lists to affect both copies, while deep copy ensures complete independence. Consider performance tradeoffs as deep copying is more expensive.",python
"Explain Python's memory management and garbage collection system.","Python uses reference counting as its primary garbage collection mechanism, supplemented by a generational garbage collector for cyclic references. When an object's reference count drops to zero, it's immediately deallocated. The GC periodically identifies and cleans up reference cycles. Key concepts include: reference counting, cyclic garbage collection, object pools for small objects, and memory allocation strategies.",python
"What are Python context managers and how do you create one?","Context managers control resource acquisition and release using the 'with' statement, ensuring proper cleanup. They're created by either implementing __enter__ and __exit__ methods or using the @contextlib.contextmanager decorator with a generator function. Common uses include file handling, database connections, locks, and network connections to guarantee resources are properly released even if exceptions occur.",python
"Describe Python's method resolution order (MRO) in multiple inheritance.","MRO determines the order in which Python searches for methods in class hierarchies with multiple inheritance. Python 3 uses the C3 linearization algorithm which maintains three key properties: children precede parents, left parents precede right parents, and no class appears before any of its ancestors. The MRO can be viewed using Class.__mro__ and ensures consistent method resolution across complex inheritance hierarchies.",python
"What are Python generators and how do they differ from regular functions?","Generators are functions that use 'yield' to return values one at a time, suspending execution between calls. Unlike regular functions that return once, generators maintain state between calls. Benefits include memory efficiency (values generated on-demand), ability to work with infinite sequences, and simpler code for iterative algorithms. They implement the iterator protocol automatically.",python
"Explain Python's asyncio framework and when to use it.","asyncio is Python's built-in framework for writing concurrent code using the async/await syntax. It uses an event loop to manage cooperative multitasking of coroutines. Best used for I/O-bound tasks that spend time waiting (network requests, database queries, file operations). Unlike threading, it provides single-threaded concurrency without context switching overhead, and unlike multiprocessing, it doesn't create separate processes.",python
"What are Python metaclasses and when would you use them?","Metaclasses are classes of classes that define how classes themselves behave. They're created by setting the __metaclass__ attribute or using the metaclass keyword in class definition. Use cases include: enforcing coding standards, registering classes in registries, adding methods or attributes automatically, implementing singletons or interfaces, and creating domain-specific languages. Example: type is the default metaclass in Python.",python
"Describe Python's duck typing and how it differs from static typing.","Duck typing is a concept where an object's suitability is determined by its behavior (methods and properties) rather than its type. The phrase comes from 'if it walks like a duck and quacks like a duck, it's a duck.' Unlike static typing that checks types at compile time, duck typing checks capabilities at runtime, enabling more flexible code but with fewer guarantees. Python uses duck typing extensively in its protocols and interfaces.",python
"What are Python descriptors and how do they work?","Descriptors are objects implementing __get__, __set__, or __delete__ methods to customize attribute access on other objects. They're the mechanism behind properties, methods, class methods, and static methods. When an attribute is accessed, Python checks if it's a descriptor and calls the appropriate descriptor method. Common uses include data validation, computed attributes, and attribute access control.",python
"Explain Python's collections module and its key data structures.","The collections module provides specialized container datatypes beyond built-in types. Key structures include: Counter (multiset for counting hashable objects), defaultdict (dict with default factory function), OrderedDict (dict that remembers insertion order), deque (double-ended queue for efficient appends/pops from both ends), namedtuple (tuple with named fields), and ChainMap (multiple dicts viewed as a single mapping).",python
"What are Python decorators with arguments and how do you implement them?","Decorators with arguments require an extra layer of functions. They're implemented as a function that takes arguments and returns a decorator, which then returns a wrapper function. The pattern looks like: def decorator_maker(arg): def decorator(func): def wrapper(*args, **kwargs): # Use arg and func here return wrapper return decorator. This enables configurable behavior modifications like @retry(times=3) or @timeout(seconds=5).",python
"Describe Python's walrus operator (:=) and its use cases.","The walrus operator (:=) introduced in Python 3.8 allows assignment within expressions. It assigns a value to a variable as part of a larger expression. Common use cases include: conditional statements where you want to use the assigned value (if (n := len(data)) > 10), loop conditions that compute values you need in the loop body, and comprehensions where you need to use a value multiple times.",python
"What is the difference between __new__ and __init__ methods in Python classes?","__new__ is a static method responsible for creating and returning a new instance, while __init__ initializes the already created instance. __new__ is called first and receives the class as its first argument, allowing it to modify instance creation or return different objects entirely. __new__ is rarely overridden except for immutable types, singletons, or when subclassing immutable types. __init__ is much more commonly customized.",python
"Explain Python's global interpreter lock (GIL) and strategies to overcome its limitations.","The GIL prevents multiple native threads from executing Python bytecode simultaneously. Strategies to overcome its limitations include: using multiprocessing instead of threading for CPU-bound tasks, releasing the GIL in C extensions during CPU-intensive operations, using asynchronous programming (asyncio) for I/O-bound concurrency, leveraging numpy/pandas operations that release the GIL, and using concurrent.futures for task parallelism.",python
"Describe Python's itertools module and its key functions.","itertools provides memory-efficient tools for creating iterators. Key functions include: combinations/permutations (combinatorial generators), cycle/repeat/count (infinite iterators), chain (combining iterators), islice (slicing iterators), groupby (grouping similar items), and tee (creating multiple independent iterators). These functions enable functional programming patterns and can significantly optimize code working with large data streams.",python
"What are Python's magic (dunder) methods and how do they enable operator overloading?","Magic methods (double underscore or 'dunder' methods) are special methods with names like __add__ or __lt__ that Python calls in response to specific operations. They enable operator overloading, allowing custom classes to work with Python's built-in operators and functions. Examples: __add__ for +, __getitem__ for [], __str__ for str(), __lt__ for <. This enables natural syntax for custom types while maintaining consistent behavior across the language.",python
"Explain the concept of monkey patching in Python and its advantages and risks.","Monkey patching is dynamically modifying classes or modules at runtime by adding, replacing, or deleting attributes. Advantages include fixing bugs in third-party code, extending functionality without subclassing, and testing by replacing dependencies with mocks. Risks include creating hard-to-debug code, breaking encapsulation, potential conflicts with future updates, and reduced code readability. Use cautiously and document thoroughly.",python